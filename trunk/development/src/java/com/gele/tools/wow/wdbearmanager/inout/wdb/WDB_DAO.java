/*
 * Created on 13.03.2005
 *
 * Class to access a WDB file
 * 
 * @author    <a href="mailto:lousy.kizura@gmail.com">Kizura aka Gerhard Leibrock </a>
 * @copyright <a href="mailto:lousy.kizura@gmail.com">Kizura aka Gerhard Leibrock </a>
 *
 * @version   $Id: WDB_DAO.java 216 2006-09-10 16:55:52Z gleibrock $
 *
 * License:
 * This software is placed under the GNU GPL.
 * For further information, see the page :
 * http://www.gnu.org/copyleft/gpl.html.
 * For a different license please contact the author.
 * 
 * $LastChangedDate: 2006-09-10 18:55:52 +0200 (So, 10 Sep 2006) $ 
 * $LastChangedBy: gleibrock $ 
 * $LastChangedRevision: 216 $ 
 * $Author: gleibrock $ 
 * $HeadURL: svn://painkiller/wdb-manager/development/src/java/com/gele/tools/wow/wdbearmanager/inout/wdb/WDB_DAO.java $
 * $Rev: 216 $
 * 
 */
package com.gele.tools.wow.wdbearmanager.inout.wdb;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.Locale;
import java.util.Vector;

import org.apache.log4j.Logger;

import com.gele.base.dbaccess.DTO_Interface;
import com.gele.base.dbaccess.WDB_DTO;
import com.gele.tools.wow.wdbearmanager.castor.WdbDef;
import com.gele.tools.wow.wdbearmanager.exception.WDBMgr_ErrorReadingWDBFile;
import com.gele.tools.wow.wdbearmanager.exception.WDBMgr_ErrorReadingXMLConfigFile;
import com.gele.tools.wow.wdbearmanager.helper.WDBInfo;
import com.gele.tools.wow.wdbearmanager.helper.WDB_Helper;

/**
 * DAO functions for WDB files
 * 
 * 2005-04-17: (After PRE-11) Fixed error with premature end of file (If a WDB
 * file is corrupt -> does not crash, just returns)
 * 
 */
public class WDB_DAO {

  // Logging with Log4J
  Logger myLogger = Logger.getLogger(WDB_DAO.class);

  // Name of the WDB file
  private String wdbFilename = "";

  // ID of the WDB file (first 16/20 byte values)
  private byte[] wbdID = null;

  public WDB_DAO() {
  }

  public WDB_DAO(String parFilename, byte[] parId) {
    this.setFilename(parFilename);
    this.setWDBID(parId);
  }

  public void setWDBID(byte[] parId) {
    this.wbdID = parId;
  }

  /**
   * @param parFilename Name of the WDB file
   */
  public void setFilename(String parFilename) {
    this.wdbFilename = parFilename;
  }

  /**
   * Reads the WDB file, creates DTO objects for each entry, returns them
   * 
   * @param parDTO
   *          template object describing the contents inside the WDB file
   * @return Collection containing all DTOs
   * @throws WDBMgr_ErrorReadingWDBFile 
   */
  public Collection getAllObjects(WDB_DTO parDTO)
      throws WDBMgr_ErrorReadingWDBFile {
    Collection retValue = new Vector();


    // Obtain information about the WDB file
    WDBInfo myWDBInfo = null;
    try {
      myWDBInfo = WDB_Helper.getWDBInfo(this.wdbFilename);
    }catch( Exception ex ) {
      throw new WDBMgr_ErrorReadingWDBFile(ex);
    }
    
    // 1. open file
    // 2. read contents into DTO objects
    // 3. return them

    BufferedInputStream myBIS = this.openWDBFile(this.wdbFilename);

    int skipBytes = parDTO.getSkipBytes();
    byte[] bufId = new byte[skipBytes];
    byte[] bufCheckEnd = (byte[])parDTO.getEofMarker().clone();
    byte[] eofMarker = (byte[])parDTO.getEofMarker().clone();
    try {
      // Skip bytes (contains ID stuff, number of bytes depends on the WDB file)
      myBIS.read(bufId);
      // compare against wdbID
      // .out.println("getAllObjects -> vergleich mit wdbID");
      // 2. read contents
      Iterator itCols = parDTO.getColumns();
      ArrayList arrAListCols = new ArrayList();
      String colName = "";
      while (itCols.hasNext()) {
        // ignore all columns that start with "info_"
        // These columns are generated by the WDBEarManager
        // to keep the information where the WDB file "comes from":
        // - Version of the WDB file
        // - Client locale
        colName = (String)itCols.next();
        if( colName.startsWith("inf_") == false ) {
          arrAListCols.add(colName);
        }
      }
      colName = "";
      Object[] arrCols = arrAListCols.toArray();
      byte byteVarChar = 0;
      byte[] bytBigInt = new byte[4];
      // StringBuffer sbuText = null;
      boolean notFinished = true;
      while (notFinished && (arrCols.length != 0)) {
        // read data for one "row"
        DTO_Interface wdbDTO = parDTO.createObject();
        wdbDTO.setColumnValue( WDB_Helper.INF_VERSION, String.valueOf(myWDBInfo.getWdbBuildVersionDec()) );
        wdbDTO.setColumnValue( WDB_Helper.INF_LOCALE,  myWDBInfo.getClientLocale() );

        // // Spalten des erzeugten DTOs
        // itCols = wdbDTO.getColumns();
        // while (itCols.hasNext()) {
        // .out.println(itCols.next());
        // }
        Object colValue = null;

        // check, if we did not reach the end of the file
        // ( 8x NULL)
        myBIS.mark(1024);
        if (myBIS.read(bufCheckEnd) == -1) {
          // EOF
          break;
        }
        // EOF Marker (normally 8 times 0)
        boolean eofFound = true;
        for (int f = 0; f < bufCheckEnd.length; f++) {
          if (bufCheckEnd[f] != eofMarker[f]) {
            eofFound = false;
            // EOF
            // .out.println("getAllObjects: Endkennung: 8 mal NULL");
          }
        }
        if (eofFound == true) {
          break;
        } else {
          myBIS.reset();
        }

        byte[] barText = new byte[2048];
        boolean errorInFile = false;
        for (int i = 0; i < arrCols.length; i++) {
          colName = (String) arrCols[i];
          // .out.println("getAllObjects - Spalte: " + colName);

          if (parDTO.getColumnType(colName) == java.sql.Types.VARCHAR) {
            // VARCHAR
            // .out.println("getAllObjects - java.sql.Types.VARCHAR");
            // read text
            // sbuText = new StringBuffer();

            // -> read unit "0" (NULL)
            int counter = 0;
            while ((byteVarChar = (byte) myBIS.read()) != 0) {
              if (byteVarChar == -1) {
                this.myLogger.warn("WDB-DAO; VARCHAR; '"+colName+"' WDB Import: end of file");
                this.myLogger.warn("File: '" + this.wdbFilename
                    + "' contains corrupt data");
                errorInFile = true;
                break;
              }

              // sbuText.append(charVarChar);
              if( byteVarChar == '\r' ) {
                barText[counter] = '\\';
                counter++;
                barText[counter] = 'r';
                counter++;
              }
              else if( byteVarChar == '\n' ) {
                barText[counter] = '\\';
                counter++;
                barText[counter] = 'n';
                counter++;
              }
              else {
                barText[counter] = byteVarChar;
                counter++;
              }
            }
            // colValue = sbuText.toString();
            colValue = new String(barText, 0, counter, "UTF-8");
          } else if (parDTO.getColumnType(colName) == java.sql.Types.INTEGER) {
            // INTEGER (32 bit integer)
            if (myBIS.read(bytBigInt, 0, 4) == -1) {
              this.myLogger.warn("WDB-DAO; INTEGER; '"+colName+"' WDB Import: end of file");
              this.myLogger.warn("File: '" + this.wdbFilename
                  + "' contains corrupt data");
              errorInFile = true;
              break;
            }
            //            if( colName.equals( "wdb_ModellID" )) {
            //            .err.println("getAllObjects - INTEGER: "
            //             + Integer.toHexString(bytBigInt[0]) + "//"
            //             + Integer.toHexString(bytBigInt[1]) + "//"
            //             + Integer.toHexString(bytBigInt[2]) + "//"
            //             + Integer.toHexString(bytBigInt[3]) + "//");
            //            }

            int iVal = (bytBigInt[0] & 0xff) + 256 * (bytBigInt[1] & 0xff)
                + 256 * 256 * (bytBigInt[2] & 0xff) + 256 * 256 * 256
                * (bytBigInt[3] & 0xff);
            colValue = new Integer(iVal);

          } else if (parDTO.getColumnType(colName) == java.sql.Types.SMALLINT) {
            // INTEGER (16 bit integer)
            if (myBIS.read(bytBigInt, 0, 2) == -1) {
              this.myLogger.warn("WDB-DAO; SMALLINT; '"+colName+"' WDB Import: end of file");
              this.myLogger.warn("File: '" + this.wdbFilename
                  + "' contains corrupt data");
              errorInFile = true;
              break;
            }
            // .out.println("getAllObjects - SMALLINT: "
            // + Integer.toHexString(bytBigInt[0]) + "//"
            // + Integer.toHexString(bytBigInt[1]) ); 

            int iVal = (bytBigInt[0] & 0xff) + 256 * (bytBigInt[1] & 0xff);
            colValue = new Integer(iVal);

          } else if (parDTO.getColumnType(colName) == java.sql.Types.TINYINT) {
            // INTEGER (8 bit integer)
            if (myBIS.read(bytBigInt, 0, 1) == -1) {
              this.myLogger.warn("WDB-DAO; TINYINT; '"+colName+"' WDB Import: end of file");
              this.myLogger.warn("File: '" + this.wdbFilename
                  + "' contains corrupt data");
              errorInFile = true;
              break;
            }
            // .out.println("getAllObjects - SMALLINT: "
            // + Integer.toHexString(bytBigInt[0]) + "//"
            // + Integer.toHexString(bytBigInt[1]) ); 

            int iVal = (bytBigInt[0] & 0xff) + 256;
            colValue = new Integer(iVal);

          } else if (parDTO.getColumnType(colName) == java.sql.Types.FLOAT) {
            // single prec float

            if (myBIS.read(bytBigInt) == -1) {
              this.myLogger.warn("WDB-DAO; FLOAT; '"+colName+"' WDB Import: end of file");
              this.myLogger.warn("File: '" + this.wdbFilename
                  + "' contains corrupt data");
              errorInFile = true;
              break;
            }
            // reverse byte order
            byte[] revBytes = new byte[4];
            revBytes[0] = bytBigInt[3];
            revBytes[1] = bytBigInt[2];
            revBytes[2] = bytBigInt[1];
            revBytes[3] = bytBigInt[0];
            ByteBuffer buf = ByteBuffer.wrap(revBytes);
            double f = buf.getFloat();
            // "just" 6 numbers for decimal fraction
            Locale locale = Locale.US;
            Locale.setDefault(locale);
            NumberFormat formatter = new DecimalFormat("#.000000");
            colValue = formatter.format(f);

          } else if (parDTO.getColumnType(colName) == java.sql.Types.CHAR) {
            int numBytesRead = 0;
            // CHAR with fixed width
            byte[] bytCHAR = new byte[parDTO.getPrecision()];

            if ((numBytesRead = myBIS.read(bytCHAR)) == -1) {
              this.myLogger.warn("WDB-DAO; CHAR; '"+colName+"' WDB Import: end of file");
              this.myLogger.warn("File: '" + this.wdbFilename
                  + "' contains corrupt data");
              errorInFile = true;
              break;
            }
            if (numBytesRead != parDTO.getPrecision()) {
              this.myLogger.warn("WDB-DAO; CHAR; '"+colName+"' WDB Import: end of file");
              this.myLogger.warn("File: '" + this.wdbFilename
                  + "' contains corrupt data");
              this.myLogger.warn("The 'char' argument has a size of '"
                  + parDTO.getPrecision() + "' " + "but only '" + numBytesRead
                  + "' bytes were found");
              errorInFile = true;
              break;
            }
            colValue = new String(bytCHAR, 0, parDTO.getPrecision(), "UTF-8");
          } else {
            // integer, hex format
            myBIS.read(bytBigInt);
            // .out.println("getAllObjects - BigInt: "
            // + Integer.toHexString(bytBigInt[0]) + "//"
            // + Integer.toHexString(bytBigInt[1]) + "//"
            // + Integer.toHexString(bytBigInt[2]) + "//"
            // + Integer.toHexString(bytBigInt[3]) + "//");

            int iVal = (bytBigInt[0] & 0xff) + 256 * (bytBigInt[1] & 0xff)
                + 256 * 256 * (bytBigInt[2] & 0xff) + 256 * 256 * 256
                * (bytBigInt[3] & 0xff);
            colValue = "0" + Integer.toHexString(iVal);
          }
          //           .out.println("getAllObjects: Value from WDB: "
          //           + colValue.toString() + "//"+ colName);
          wdbDTO.setColumnValue(colName, colValue);
        }// for... all columns
        if (errorInFile == false) {
          retValue.add(wdbDTO);
        } else {
          setWarningMessage(
              "Error reading WDB file: '" + this.wdbFilename + "' - Premature end of file");
        }
        // .out.println("getAllObjects: Neuer Datensatz");
      }// while...
      myBIS.close();
    } catch (IOException ex) {
      throw new WDBMgr_ErrorReadingWDBFile(
          "Error reading WDB file: '" + this.wdbFilename + "'", ex);
    }

    return retValue;
  }// getAllObjects
  
  private String warningMessage = "";
  public void setWarningMessage( String parMsg ) {
    this.warningMessage = parMsg;
  }
  public String getWarningMessage() {
    return this.warningMessage;
  }


  private BufferedInputStream openFile(Class parClass, String parFilename)
      throws WDBMgr_ErrorReadingXMLConfigFile {
    WdbDef myWdbDef = null;
    InputStream ct_insInput = null;
    try {
      String pkg = parClass.getPackage().getName();
      pkg = pkg.replace('.', File.separatorChar);
      File myFile = new File(pkg, parFilename);
      ct_insInput = new FileInputStream(myFile);
      myWdbDef = (WdbDef) WdbDef.unmarshal(new BufferedReader(
          new InputStreamReader(ct_insInput)));
      ct_insInput.close();
    } catch (Exception ex) {
      // does not work as a filename, maybe inside a JAR -> try it as a resource
      try {
        return new BufferedInputStream(ct_insInput);
      } catch (NullPointerException exx) {
        // exx.printStackTrace();
        throw new WDBMgr_ErrorReadingXMLConfigFile(parFilename
            + ": file not found." + exx.getLocalizedMessage(), exx);
      } catch (Exception exx) {
        // exx.printStackTrace();
        throw new WDBMgr_ErrorReadingXMLConfigFile("Could not locate file: "
            + parFilename + "\n" + " Tried to read it as a file '"
            + new File(parFilename).getAbsolutePath()
            + "' and as a resource.\n", exx);
      }
    }// could not read as file
    if (ct_insInput == null) {
      throw new WDBMgr_ErrorReadingXMLConfigFile("Error reading WDB file: '"
          + parFilename + "'");
    } else {
      return new BufferedInputStream(ct_insInput);

    }
  }// openFile -> relative to class

  /*
   * Read the config file using Castor generated class Ipal_Imp_Stv_Konfig<br/>
   * 
   * @return instance of Ipal_Imp_Stv_Konfig
   * 
   * @throws STVI_ErrorReadingConfigFile if the system could not locate/read the
   * XML config file
   */
  private BufferedInputStream openWDBFile(String parFilename)
      throws WDBMgr_ErrorReadingWDBFile {

    // WDB file
    InputStream ct_insInput = null;
    try {
      ct_insInput = new FileInputStream(new File(parFilename));
      return new BufferedInputStream(ct_insInput);
    } catch (Exception ex) {
      // does not work as a filename, maybe inside a JAR -> try it as a resource
      try {
        ct_insInput = this.getClass().getResourceAsStream("/" + parFilename);
      } catch (Exception exx) {
        throw new WDBMgr_ErrorReadingWDBFile("Could not locate file: "
            + parFilename + "\n" + " Tried to read it as a file '"
            + new File(parFilename).getAbsolutePath()
            + "' and as a resource.\n", exx);
      }// Exception... -> File not found inside JAR
    }// Exception... -> File not found

    if (ct_insInput == null) {
      throw new WDBMgr_ErrorReadingWDBFile("Error reading WDB file: '"
          + parFilename + "'");
    } else {
      return new BufferedInputStream(ct_insInput);
    }
  } // openWDBFile
}